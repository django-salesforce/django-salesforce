#!/usr/bin/env python

"""
A terminal browser, similar to less(1).

Adapted from example provided by jquast in wcwidth using blessed.
From https://github.com/jquast/wcwidth/blob
/b29897e5a1b403a0e36f7fc991614981cbc42475/bin/wcwidth-browser.py
"""

# pylint: disable=C0103,W0622
#         Invalid constant name "echo"
#         Invalid constant name "flushout" (col 4)

import signal
import functools
import logging
from typing import List

import blessed

try:
    _input = raw_input
except NameError:
    _input = input


#: print function alias, does not end with line terminator.
echo = functools.partial(print, end='')
flushout = functools.partial(print, end='', flush=True)
#: printable length

PRINTLEN = 79
LOGGER = logging.getLogger('main_log')


def readline(term, width):
    """A rudimentary readline implementation."""
    text = ''
    while True:
        inp = term.inkey()
        if inp.code == term.KEY_ENTER:
            break
        if inp.code == term.KEY_ESCAPE or inp == chr(3):
            text = None
            break
        if not inp.is_sequence and len(text) < width:
            text += inp
            echo(inp)
            flushout()
        elif inp.code in (term.KEY_BACKSPACE, term.KEY_DELETE):
            if text:
                text = text[:-1]
                echo('\b \b')
            flushout()
    return text


class RoleGenerator:
    """Generator yields account-role options."""

    # pylint: disable=R0903
    #         Too few public methods (0/2)
    def __init__(self, items):
        """
        Class constructor.

        :param width: generate characters of given width.
        :param items: List of string for account or role, with index in string.
        """
        self.options = (
            _ for _ in items)

    def __iter__(self):
        """Special method called by iter()."""
        return self

    def __next__(self):
        """Special method called by next()."""
        while True:
            account_role = next(self.options)
            return account_role


class Style:
    """Styling decorator class instance for terminal output."""

    # pylint: disable=R0903
    #         Too few public methods (0/2)
    @staticmethod
    def attr_major(text):
        """non-stylized callable for "major" text, for non-ttys."""
        return text

    @staticmethod
    def attr_minor(text):
        """non-stylized callable for "minor" text, for non-ttys."""
        return text

    delimiter = '|'
    continuation = ' $'
    header_hint = '-'
    header_fill = '='
    name_len = 79
    alignment = 'left'

    def __init__(self, **kwargs):
        """
        Class constructor.

        Any given keyword arguments are assigned to the class attribute of the
        same name.
        """
        for key, val in kwargs.items():
            setattr(self, key, val)


class Screen:
    """Represents terminal style, data dimensions, and drawables."""

    def __init__(self, term, style, **kwargs):
        """

        :param term: blessed.Terminal instance
        :param style: style formatting to apply for blessed.Terminal text
        :keyword introduction_message: String, ideally <=79 chars long that
          will be displayed at top of TUI.
        """
        self.term = term
        self.style = style
        self.intro_msg_fmt = (kwargs.get(
            "introduction_message",
            "Account and role options. After making a decision, "
            "exit (q) this view to return to the prompt to enter "
            "your selection."))

    @property
    def header(self):
        """Text of joined segments producing full heading."""
        return self.head_item * self.num_columns

    @property
    def hint_width(self):
        """Width of a column segment."""
        return sum((len(self.style.delimiter),
                    self.style.name_len,))

    @property
    def head_item(self):
        """Text of a single column heading."""

        def alignment(*args):
            if self.style.alignment == 'right':
                return self.term.rjust(*args)
            return self.term.ljust(*args)

        txt = alignment('', self.hint_width, self.style.header_fill)
        return self.style.attr_major(txt)

    def msg_intro(self):
        """Introductory message disabled above heading."""
        return self.term.center(self.intro_msg_fmt.format(
            delim=self.style.attr_minor(self.style.delimiter),
            )).rstrip()

    @property
    def row_ends(self):
        """Bottom of page."""
        return self.term.height - 1

    @property
    def num_columns(self):
        """Number of columns displayed."""
        # removed ability to have multiple columns in a row.
        # if self.term.is_a_tty:
        #     return self.term.width // self.hint_width
        return 1

    @property
    def num_rows(self):
        """Number of rows displayed."""
        return self.row_ends - self.row_begins - 1

    @property
    def row_begins(self):
        """Top row displayed for content."""
        # pylint: disable=R0201
        # Method could be a function (col 4)
        return 2

    @property
    def page_size(self):
        """Number of unicode text displayed per page."""
        return self.num_rows * self.num_columns


class Pager:
    """A less(1)-like browser for browsing unicode characters."""
    # pylint: disable=too-many-instance-attributes

    #: screen state for next draw method(s).
    STATE_CLEAN, STATE_DIRTY, STATE_REFRESH = 0, 1, 2

    def __init__(self, term, screen, character_factory, **kwargs):
        """
        Class constructor.

        :param term: blessed Terminal class instance.
        :type term: blessed.Terminal
        :param screen: Screen class instance.
        :type screen: Screen
        :param character_factory: Character factory generator.
        :type character_factory: callable returning iterable.
        """
        self.term = term
        self.screen = screen
        self.character_factory = character_factory
        self.dirty = self.STATE_REFRESH
        self.last_page = 0
        self._page_data = list()
        self.items = kwargs.get("items")

    def on_resize(self, *args):
        """Signal handler callback for SIGWINCH."""
        # pylint: disable=W0613
        #         Unused argument 'args'
        if self.term.width < self.screen.hint_width:
            LOGGER.error("Screen too small (%s), must be at least %s",
                         self.term.width, self.screen.hint_width)
            return
        self._set_lastpage()
        self.dirty = self.STATE_REFRESH

    def _set_lastpage(self):
        """Calculate value of class attribute ``last_page``."""
        self.last_page = (len(self._page_data) - 1) // self.screen.page_size

    def display_initialize(self):
        """Display 'please wait' message, and narrow build warning."""
        echo(self.term.home + self.term.clear)
        echo(self.term.move_y(self.term.height // 2))
        echo(self.term.center('Initializing page data ...').rstrip())
        flushout()

    def initialize_page_data(self):
        """Initialize the page data for the given screen."""
        # pylint: disable=attribute-defined-outside-init
        if self.term.is_a_tty:
            self.display_initialize()
        self.character_generator = self.character_factory(items=self.items)
        self._page_data = list()
        while True:
            try:
                self._page_data.append(next(self.character_generator))
            except StopIteration:
                break
        self._set_lastpage()

    def page_data(self, idx, offset):
        """
        Return character data for page of given index and offset.

        :param idx: page index.
        :type idx: int
        :param offset: scrolling region offset of current page.
        :type offset: int
        :returns: list of tuples in form of ``(ucs, name)``
        :rtype: list[(unicode, unicode)]
        """
        size = self.screen.page_size

        while offset < 0 and idx:
            offset += size
            idx -= 1
        offset = max(0, offset)

        while offset >= size:
            offset -= size
            idx += 1

        if idx == self.last_page:
            offset = 0
        idx = min(max(0, idx), self.last_page)

        start = (idx * self.screen.page_size) + offset
        end = start + self.screen.page_size
        return (idx, offset), self._page_data[start:end]

    def _run_notty(self, writer):
        """Pager run method for terminals that are not a tty."""
        page_idx = page_offset = 0
        while True:
            npage_idx, _ = self.draw(writer, page_idx + 1, page_offset)
            if npage_idx == self.last_page:
                # page displayed was last page, quit.
                break
            page_idx = npage_idx
            self.dirty = self.STATE_DIRTY

    def _run_tty(self, writer, reader):
        """Pager run method for terminals that are a tty."""
        # allow window-change signal to reflow screen
        try:
            signal.signal(signal.SIGWINCH, self.on_resize)
        except AttributeError:
            # windows does not support this. disabling resize for it for now
            # until a better workaround can be found.
            LOGGER.debug("No signal.SIGWINCH on this platform, cannot "
                         "support resize.")

        page_idx = page_offset = 0
        while True:
            if self.dirty:
                page_idx, page_offset = self.draw(writer,
                                                  page_idx,
                                                  page_offset)
                self.dirty = self.STATE_CLEAN
            inp = reader(timeout=0.25)
            if inp is not None:
                nxt, noff = self.process_keystroke(inp,
                                                   page_idx,
                                                   page_offset)
                if self.dirty:
                    continue
            if not self.dirty:
                self.dirty = nxt != page_idx or noff != page_offset
            page_idx, page_offset = nxt, noff
            if page_idx == -1:
                return

    def run(self, writer, reader):
        """
        Pager entry point.

        In interactive mode (terminal is a tty), run until
        ``process_keystroke()`` detects quit keystroke ('q').  In
        non-interactive mode, exit after displaying all unicode points.

        :param writer: callable writes to output stream, receiving unicode.
        :type writer: callable
        :param reader: callable reads keystrokes from input stream, sending
                       instance of blessed.keyboard.Keystroke.
        :type reader: callable
        """
        self.initialize_page_data()
        if not self.term.is_a_tty:
            self._run_notty(writer)
        else:
            self._run_tty(writer, reader)

    def process_keystroke(self, inp, idx, offset):
        """
        Process keystroke ``inp``, adjusting screen parameters.

        :param inp: return value of blessed.Terminal.inkey().
        :type inp: blessed.keyboard.Keystroke
        :param idx: page index.
        :type idx: int
        :param offset: scrolling region offset of current page.
        :type offset: int
        :returns: tuple of next (idx, offset).
        :rtype: (int, int)
        """
        if inp.lower() in ('q', 'Q'):
            # exit
            return (-1, -1)
        self._process_keystroke_commands(inp)
        idx, offset = self._process_keystroke_movement(inp, idx, offset)
        return idx, offset

    def _process_keystroke_commands(self, inp):
        """Process keystrokes that issue commands (side effects)."""
        if inp in ('_', '-'):
            # adjust name length -2
            nlen = max(1, self.screen.style.name_len - 2)
            if nlen != self.screen.style.name_len:
                self.screen.style.name_len = nlen
                self.on_resize(None, None)
        elif inp in ('+', '='):
            # adjust name length +2
            nlen = min(self.term.width - 8, self.screen.style.name_len + 2)
            if nlen != self.screen.style.name_len:
                self.screen.style.name_len = nlen
                self.on_resize(None, None)

    def _process_keystroke_movement(self, inp, idx, offset):
        """Process keystrokes that adjust index and offset."""
        term = self.term
        # a little vi-inspired.
        if inp in ('y', 'k') or inp.code in (term.KEY_UP,):
            # scroll backward 1 line
            offset -= self.screen.num_columns
        elif inp in ('e', 'j') or inp.code in (term.KEY_ENTER,
                                               term.KEY_DOWN,):
            # scroll forward 1 line
            offset = offset + self.screen.num_columns
        elif inp in ('f', ' ') or inp.code in (term.KEY_PGDOWN,):
            # scroll forward 1 page
            idx += 1
        elif inp == 'b' or inp.code in (term.KEY_PGUP,):
            # scroll backward 1 page
            idx = max(0, idx - 1)
        elif inp == 'F' or inp.code in (term.KEY_SDOWN,):
            # scroll forward 10 pages
            idx = max(0, idx + 10)
        elif inp == 'B' or inp.code in (term.KEY_SUP,):
            # scroll backward 10 pages
            idx = max(0, idx - 10)
        elif inp.code == term.KEY_HOME:
            # top
            idx, offset = (0, 0)
        elif inp == 'G' or inp.code == term.KEY_END:
            # bottom
            idx, offset = (self.last_page, 0)
        elif inp == '\x0c':
            self.dirty = True
        return idx, offset

    def draw(self, writer, idx, offset):
        """
        Draw the current page view to ``writer``.

        :param callable writer: callable writes to output stream, receiving unicode.
        :param int idx: current page index.
        :param int offset: scrolling region offset of current page.
        :returns: tuple of next (idx, offset).
        :rtype: (int, int)
        """
        # as our screen can be resized while we're mid-calculation,
        # our self.dirty flag can become re-toggled; because we are
        # not re-flowing our pagination, we must begin over again.
        while self.dirty:
            self.draw_heading(writer)
            self.dirty = self.STATE_CLEAN
            (idx, offset), data = self.page_data(idx, offset)
            for txt in self.page_view(data):
                writer(txt)
        self.draw_status(writer, idx)
        flushout()
        return idx, offset

    def draw_heading(self, writer):
        """
        Conditionally redraw screen when ``dirty`` attribute is valued REFRESH.

        When Pager attribute ``dirty`` is ``STATE_REFRESH``, cursor is moved
        to (0,0), screen is cleared, and heading is displayed.

        :param callable writer: callable writes to output stream, receiving unicode.
        :return: True if class attribute ``dirty`` is ``STATE_REFRESH``.
        :rtype: bool
        """
        if self.dirty == self.STATE_REFRESH:
            writer(''.join(
                (self.term.home, self.term.clear,
                 self.screen.msg_intro(), '\n',
                 self.screen.header, '\n',)))
            return True
        return False

    def draw_status(self, writer, idx):
        """
        Conditionally draw status bar when output terminal is a tty.

        :param callable writer: callable writes to output stream, receiving unicode.
        :param int idx: current page position index.
        :type idx: int
        """
        if self.term.is_a_tty:
            writer(self.term.hide_cursor())
            style = self.screen.style
            writer(self.term.move(self.term.height - 1))
            if idx == self.last_page:
                last_end = '(END)'
            else:
                last_end = '/{0}'.format(self.last_page)
            txt = ('Page {idx}{last_end} - '
                   '{q} to quit, [keys: {keyset}]'
                   .format(idx=style.attr_minor('{0}'.format(idx)),
                           last_end=style.attr_major(last_end),
                           keyset=style.attr_major('kjfb-='),
                           q=style.attr_minor('q')))
            writer(self.term.center(txt).rstrip())

    def page_view(self, data):
        """
        Generator yields text to be displayed for the current unicode pageview.

        :param list[str] data: The current page's data as str.
        :returns: generator for full-page text for display
        """
        if self.term.is_a_tty:
            yield self.term.move(self.screen.row_begins, 0)
        # sequence clears to end-of-line
        clear_eol = self.term.clear_eol
        # sequence clears to end-of-screen
        clear_eos = self.term.clear_eos

        # track our current column and row, where column is
        # the whole segment of unicode value text, and draw
        # only self.screen.num_columns before end-of-line.
        #
        # use clear_eol at end of each row to erase over any
        # "ghosted" text, and clear_eos at end of screen to
        # clear the same, especially for the final page which
        # is often short.
        col = 0
        for each in data:
            val = self.text_entry(each)
            col += 1
            if col == self.screen.num_columns:
                col = 0
                if self.term.is_a_tty:
                    val = ''.join((val, clear_eol, '\n'))
                else:
                    val = ''.join((val.rstrip(), '\n'))
            yield val

        if self.term.is_a_tty:
            yield ''.join((clear_eol, '\n', clear_eos))

    def text_entry(self, text):
        """
        Display a single column segment row describing ``text``.

        :param str text: target string.
        :return: formatted text for display.
        :rtype: unicode
        """
        style = self.screen.style
        if len(text) > style.name_len:
            idx = max(0, style.name_len - len(style.continuation))
            text = ''.join((text[:idx], style.continuation if idx else ''))
        fmt = ' '.join(('{text:<{name_len}s}{delimiter}',))
        delimiter = style.attr_minor(style.delimiter)
        disp_text = style.attr_major(text)

        return fmt.format(name_len=style.name_len,
                          printlen=PRINTLEN,
                          delimiter=delimiter,
                          text=disp_text)


def text_user_interface(
        items: List[str],
        **kwargs):
    """
    Create a text-based user interface that displays the iterable `items`
    as one item per row.

    :param items: list of strings where each string represents a row to be
      displayed in the TUI.
    :keyword introduction_message:  Optionally override the TUI first line
      display text.
    :return: 0
    """
    term = blessed.Terminal()
    style = Style()

    # if the terminal supports colors, use a Style instance with some
    # standout colors (magenta, cyan).
    if term.number_of_colors:
        style = Style(attr_major=term.magenta,
                      attr_minor=term.bright_cyan,
                      alignment="left")
    style.name_len = 79

    screen = Screen(term, style, **kwargs)
    pager = Pager(term, screen, RoleGenerator, items=items)

    with term.location(), term.cbreak(), \
            term.fullscreen(), term.hidden_cursor():
        pager.run(writer=echo, reader=term.inkey)
    return 0


def tui_instructions():
    """
    Open a TUI that lists instructions on how to use it with example
    text to allow testing in this sandbox.
    """
    intro = "Instructions for using this view. Press q to exit and return " \
            "to prompt."
    instructions = [
        "If there are more items than can be displayed on screen, ",
        "they will be paginated.",
        "See the the page count and current page number in the bottom.",
        "",
        "~Ways to scroll or change pages~",
        "To scroll forward 1 line:",
        "  - Use down arrow key, e, j, or enter key",
        "To scroll backward 1 line:",
        "  - Use up arrow key, y, or k",
        "To scroll forward 1 page:",
        "  - Use page down key, f, or space",
        "To scroll backward 1 page:",
        "  - Use page up key or b",
        "To scroll forward 10 pages:",
        "  - Use shift+down or F",
        "To scroll backward 10 pages:",
        "  - Use shift+up or B",
        "To seek to top:",
        "  - Use home key",
        "To seek to bottom",
        "  - Use end key or G",
        "The mouse scroll can also be used to navigate through pages.",
        "",
        "The interface sets a default line length to fit into the terminal.",
        "If a line is longer than this, it ends in a $ symbol which",
        "indicates a continuation.",
        "The line length can be adjusted to expand to show the text",
        "or reduced to fit into a smaller terminal.",
        "",
        "~To adjust line length~",
        "To increase line length:",
        "  - Use + or = key",
        "To reduce line length:",
        "  - Use - or _ key",
        "",
        "Here is an example long line to test:",
        "This is a line that is intentionally longer than default line "
        "length for this view. Test adjusting line length with this.",
        "Be aware that the interface will error if the terminal is smaller ",
        "than the default or adjusted line length.",
        "",
        "",
        "",
        "Below is just random text to create many pages for testing",
        "usage of navigation keys",
        "",
        ]
    lorem = [
        "Lorem ipsum dolor sit amet,",
        "consectetur adipiscing elit.",
        "Cras fringilla lacus a volutpat vehicula.",
        "Donec laoreet urna quis semper egestas.",
        "Maecenas vitae metus sit amet libero aliquet auctor.",
        "Maecenas tristique lorem eu metus consequat blandit.",
        "Duis varius erat bibendum nunc interdum ultrices.",
        "Quisque in mauris id nunc convallis blandit.",
        "Duis ac sapien a sapien fermentum rhoncus.",
        "Vestibulum vel nibh nec leo egestas aliquam.",
        "Curabitur fermentum arcu quis odio condimentum,",
        "ut congue metus ultrices.",
        "Quisque tincidunt odio a ligula ultrices euismod.",
        "Phasellus vel nibh non nisl efficitur lobortis.",
        "Nunc porta ligula et ligula eleifend,",
        "et blandit erat blandit.",
        "Donec at sapien vestibulum, feugiat quam sit amet,",
        "ultricies nulla.",
        "Fusce convallis leo eu lectus volutpat,",
        "auctor vulputate orci congue.",
        "Mauris tincidunt velit a massa aliquet congue.",
        "Integer eget elit ut sapien accumsan euismod.",
        "Praesent in lacus at libero pretium fringilla.",
    ]*100
    instructions.extend(lorem)

    text_user_interface(instructions, introduction_message=intro)


def interactive_account_role_selection(
        account_roles: List[str],
        max_retries: int = 2,
        default="r"
) -> int:
    """
    Prompt user for options for displaying role options in TUI,
    instructions for use of TUI, or role selection index. Validate
    input and exit if fails validation beyond max_retries.
    Returns the final integer selection for an account-role.

    :param account_roles: List of strings representing accounts and their
      indexed role options.
    :param max_retries: number of invalid user entries before exiting.
    :param default: sets default response if bare return.
    :return: int
    """
    invalid_responses = 0

    def validate_response(response):
        """
        Only allow 'r', 'R', 'i', 'I', or integer.
        Return True if valid.
        """
        # allow bare return to use default if defined.
        if response == '' and default is not None:
            return True
        try:
            int(response)
            return True
        except ValueError:
            if response.lower() in ("r", "i"):
                return True
        return False

    # the block of text to display before the user prompt.
    pre_prompt = (
        "Select an account-role option.",
        "  - To view options, enter: r",
        "  - To view instructions for usage of the account-role options view, "
        "enter: i",
        "  - To choose selection, enter the integer index"
    )
    for row in pre_prompt:
        print(row)
    default_selection_prompt = ""
    if default:
        default_selection_prompt = f" ({default})"
    while True:
        selection = _input(f"Enter selection{default_selection_prompt}: ")
        if not validate_response(selection):
            invalid_responses += 1
            message = "We didn't recognize that response."
            assert invalid_responses < max_retries, (
                message + " Max retries exceeded, exiting.")
            print(message + " Please try again.")
        if validate_response(selection):
            # reset counter
            invalid_responses = 0
            if selection.lower() == 'i':
                tui_instructions()
            elif selection == '' or selection.lower() == 'r':
                text_user_interface(account_roles)
            else:
                return int(selection)
