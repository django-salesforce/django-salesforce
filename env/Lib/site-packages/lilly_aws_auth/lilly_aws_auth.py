#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""
Generate temporary credentials (Access Key and Secret Access Key) for Lilly AWS
"""

from __future__ import with_statement
from __future__ import absolute_import
from __future__ import print_function
import logging
import sys
import os
from os.path import expanduser
from textwrap import dedent, wrap

import boto3

from lilly_aws_auth.federation import LillyFederation
from lilly_aws_auth.aws_accounts import AwsSamlLogin
from lilly_aws_auth.configuration import apply_credentials_and_config, \
    LoginProfile, list_profiles
from lilly_aws_auth.cli import command_line
from lilly_aws_auth.utils import check_proxy, setup_logger, \
    determine_version, multiline_command_seperator


def store_a_profile(arguments):
    """
    Create and store a profile.

    :param arguments: argparse arguments, just pass them all in.
    """
    new_profile = LoginProfile(
        login_profile=arguments.login_profile,
        aws_profile=arguments.aws_profile,
        username=arguments.username,
        entry_url=arguments.entry_url,
        role_arn=arguments.role_arn,
        region=arguments.aws_region,
        output=arguments.output_format,
        duration=arguments.duration,
        account=arguments.account,
        account_id=arguments.account_id,
        role=arguments.role
    )
    invocation = new_profile.save()
    print(invocation)
    sys.exit()


class NoInteractiveSupport(Exception):
    """Raise when using entry points that cannot support interactive login."""
    pass


class Login:
    """Login flow through Lilly federation and then AWS."""

    def __init__(self, arguments):
        self.arguments = arguments
        self._role = None
        self.saml_response = None
        self.preselection_successful = False
        self._stored_login_profile = None
        self.username = None
        self.duration = None
        self.region = None
        self.output = None
        self.login_profile = None
        self.aws_profile = None
        self.role_arn = None
        self.principal_arn = None
        self.account = None
        self.role = None
        self.lz_urls = [
            "https://federate.xh1.lilly.com/idp/startSSO.ping?PartnerSpId=AWS-firstmile",
            "https://aws-login.am.lilly.com",
            "http://aws-login.am.lilly.com",
        ]

    def login(self):
        """
        Main public method to start login flow and set object attributes
        for downstream use.
        """
        if self.arguments.login_profile:
            self._login_with_stored_login_profile()
        else:
            self._login_interactively()
        self._set_attrs()

    def _login_with_stored_login_profile(self):
        """Get a stored profile and validate and return the role."""
        login_profile = LoginProfile()
        login_profile.load(self.arguments.login_profile)
        if login_profile.load_success:
            identity_provider_url = self.arguments.entry_url or \
                                   login_profile.entry_url

            federation = LillyFederation(
                identity_provider_url=identity_provider_url,
                switch_device=self.arguments.switch_device,
                role_arn=login_profile.role_arn,
                username=self.arguments.username or login_profile.username,
                password=self.arguments.password if self.arguments.password
                else None
            )
            auth_response = federation.authenticate()
            saml_response = auth_response.saml_response
            # get the accounts object constructed for looking up against AWS.
            if identity_provider_url in self.lz_urls:
                # auth_response = federation.authenticate()
                self._role = auth_response
                self.preselection_successful = True
            else:
                aws_accounts = AwsSamlLogin(
                    saml_response=saml_response,
                    preselected_role_arn=login_profile.role_arn,
                    # these filters will only be used if the pre-selected profile
                    # fails validation.
                    filter_account=self.arguments.filter_account if
                    self.arguments.filter_account else None,
                    filter_role=self.arguments.filter_role if
                    self.arguments.filter_role else None
                )
                self._role = aws_accounts.get_role_info()
                self.preselection_successful = aws_accounts.preselection_successful

            self.saml_response = saml_response
            self._stored_login_profile = login_profile
            self.login_profile = login_profile.login_profile
            self.username = federation.username
        else:
            self._login_interactively()

    def _login_interactively(self):
        """Login without a stored profile, with interactive prompts."""

        identity_provider_url = self.arguments.entry_url or \
                               'http://aws-admin.lilly.com'
        # prevent double interactive prompt if using IDP provided by
        # aws-login.am.lilly.com since it handles everything in one step.
        federation = LillyFederation(
            identity_provider_url=identity_provider_url,
            switch_device=self.arguments.switch_device,
            username=self.arguments.username if self.arguments.username else
            None,
            password=self.arguments.password if self.arguments.password else
            None,
            filter_account=self.arguments.filter_account if
            self.arguments.filter_account else None,
            filter_role=self.arguments.filter_role if
            self.arguments.filter_role else None
        )
        auth_response = federation.authenticate()
        saml_response = auth_response.saml_response
        if self.arguments.entry_url not in self.lz_urls:
            aws_accounts = AwsSamlLogin(
                saml_response=saml_response,
                filter_account=self.arguments.filter_account if
                self.arguments.filter_account else None,
                filter_role=self.arguments.filter_role if
                self.arguments.filter_role else
                None)
            self._role = aws_accounts.get_role_info()
        else:
            self._role = auth_response
        self.saml_response = saml_response
        self.login_profile = None
        self.preselection_successful = False
        self.username = federation.username

    def _set_attrs(self):
        """Set some attributes we need downstream."""
        # set all required downstream variables.
        if self._stored_login_profile and \
                self._stored_login_profile.load_success:
            self.duration = self.arguments.duration or \
                            self._stored_login_profile.duration
            self.region = self.arguments.aws_region or \
                          self._stored_login_profile.region
            self.output = self.arguments.output_format or \
                          self._stored_login_profile.output
            self.aws_profile = self._stored_login_profile.aws_profile
            if self.arguments.aws_profile:
                self.aws_profile = self.arguments.aws_profile
        else:
            self.duration = self.arguments.duration or 3600
            self.region = self.arguments.aws_region or 'us-east-2'
            self.output = self.arguments.output_format or 'json'
            self.aws_profile = self.arguments.aws_profile or 'saml'
        self.role_arn = self._role.role_arn
        self.principal_arn = self._role.principal_arn
        self.account = self._role.account
        self.role = self._role.role


def main():
    """Main entrypoint."""

    # parse the arguments (includes setting args to default values as defined)
    arguments = command_line()
    # disable traceback if not in debug
    if not arguments.debug:
        python_version = determine_version()
        # known issue https://bugs.python.org/issue12276
        if python_version in ['3.5.2', '3.6.1']:
            sys.tracebacklimit = None
        else:
            sys.tracebacklimit = 0
    if arguments.debug:
        # default logger and urrllib3 logging.
        logging.basicConfig(level=logging.DEBUG)
    # setup our applications own logger, separate from the third party libs
    setup_logger(arguments)
    LOGGER = logging.getLogger('main_log')
    check_proxy()

    if arguments.subparser_name == 'list':
        print(list_profiles())
        return

    if arguments.subparser_name == 'configure':
        store_a_profile(arguments)

    login = Login(arguments)
    login.login()

    # use STS to get credentials

    if os.environ.get("AWS_PROFILE"):
        # if this has been set, temporarily remove it from the environment
        # mapping so boto3 does not try to load. The environment variable
        # will only be unset for the current process and any child processes
        LOGGER.debug("Found AWS_PROFILE was set in the environment. "
                     "Unsetting for this session as this is attempting to "
                     "create new credentials.")
        del os.environ["AWS_PROFILE"]
    # Set access key id, secret access key to prevent attempts
    #  to load credentials from environment since we are trying to create
    # new credentials.
    boto_client = boto3.client("sts", aws_access_key_id="",
                               aws_secret_access_key="")
    response = boto_client.assume_role_with_saml(
        RoleArn=login.role_arn,
        PrincipalArn=login.principal_arn,
        SAMLAssertion=login.saml_response,
        DurationSeconds=login.duration
    )
    note = "Credential for '{0}:{1}'; expires at '{2}'".format(
        login.account, login.role, response["Credentials"]["Expiration"])
    aws_access_key_id = response["Credentials"]["AccessKeyId"]
    aws_session_token = response["Credentials"]["SessionToken"]
    aws_secret_access_key = response["Credentials"]["SecretAccessKey"]
    settings = {
        'aws_session_token': aws_session_token,
        'aws_access_key_id': aws_access_key_id,
        'aws_secret_access_key': aws_secret_access_key,
        'note': note,
        'region': login.region,
        'output': login.output
    }

    credentials_file = '~/.aws/credentials'
    config_file = '~/.aws/config'
    apply_credentials_and_config(settings, profile_name=login.aws_profile,
                                 credentials_path=credentials_file,
                                 config_path=config_file)
    # Give the user some basic info as to what has just happened
    message = """\
    Your AWS keys for {account}:{role} have been saved in '{filename}'
    under the '{profilename}' profile. Your AWS keys will expire at
    {expiration}. At any time, you may re-run this script to refresh your
    AWS keys. To use AWS CLI with your AWS keys, use the '--profile'
    option, e.g. 'aws --profile {profilename} ec2 describe-instances' or,
    to always default to '{profilename}' profile, set the environment variable
    AWS_PROFILE={profilename}
    """.format(filename=os.path.abspath(expanduser(credentials_file)),
               profilename=login.aws_profile,
               expiration=response["Credentials"]["Expiration"],
               account=login.account,
               role=login.role
              )
    print('-'*79)
    for line in wrap(dedent(message), 79):
        print(line)
    print('-'*79)

    if not login.preselection_successful:
        pre_message = """\
        You can save a Login Profile from your previous login in order to
        skip the interactive prompts next time. To save it, run the command
        below, modifying parts that you would like to change such as the
        login-profile name or adding an aws-profile name:
        """
        message = """\
        lilly_aws_auth configure separator
          --entry-url {url} separator
          --username {username} separator
          --account {account} separator
          --role {role} separator
          --role-arn {role_arn} separator
          -d {duration} separator
          --aws-region {region} separator
          --output-format {output} separator
          --login-profile {login_profile}
        """.format(
            login_profile=login.aws_profile,
            url=arguments.entry_url or 'http://aws-admin.lilly.com',
            username=login.username,
            account=login.account,
            role=login.role,
            role_arn=login.role_arn,
            duration=login.duration,
            region=login.region,
            output=login.output
        )
        message = multiline_command_seperator(message)
        for line in wrap(dedent(pre_message), 79):
            print(line)
        print("\n")
        print(dedent(message))


if __name__ == "__main__":
    main()
