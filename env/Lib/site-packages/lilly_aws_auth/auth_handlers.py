#!/usr/bin/env python
"""
Chain of Responsibility handlers for web responses returned as part of the authentication flow
"""

# Python 2/3 compatibility
from __future__ import absolute_import, print_function
from builtins import input

import getpass
import logging
from requests import Request

from .utils import retry_loop
from .webpage import urljoin
from .aws_accounts import LillyAwsLogin

LOGGER = logging.getLogger('main_log')


class AuthHandler:
    """
    Base class for response handlers utilizing the chain of responsibility
    design pattern
    """

    _next_handler = None

    def next(self, handler):
        """
        Set the next handler in the handler chain. Returns the handler
        being passed so that calls can be chained together
        """
        self._next_handler = handler
        return handler

    def handle_response(self, document, auth_context):
        """
        Base method called to handle response, will continue to pass control
        onto the next handler in the chain until one of the handlers can
        handle the request
        """
        return_val = self._handle_response(document, auth_context)
        if return_val or auth_context.saml_response:
            return return_val
        if self._next_handler:
            return self._next_handler.handle_response(document, auth_context)
        return None

    def _handle_response(self, document, auth_context):
        """
        Abstract method meant to be overriden by concrete implementations
        of this class. Method should return a request object if handling
        the request, otherwise return None
        """
        pass


class AWSSAMLResponseHandler(AuthHandler):
    """
    Handler class that seeks to detect a SAML Response destined for the AWS
    Login page
    """
    def _handle_response(self, document, auth_context):
        if document.has('input[name="SAMLResponse"]') and \
                 document.select_one('form').get('action') \
                == 'https://signin.aws.amazon.com/saml':
            LOGGER.debug('AWS SAML Response detected')
            auth_context.saml_response = document.select_one(
                'input[name="SAMLResponse"]').get('value')


class LillySAMLResponseHandler(AuthHandler):
    """
    Handler class that seeks to detect a SAML Response destined for the
    Lilly AWS Login Page
    """
    def _handle_response(self, document, auth_context):
        if document.has('input[name="SAMLResponse"]') and \
                 document.select_one('form').get('action') \
                == 'https://aws-login.am.lilly.com/awsauth/return.php':
            LOGGER.debug('Lilly SAML Response detected')
            return document.extract_form().build_request()
        return None


class FormRedirectHandler(AuthHandler):
    """
    Handler for Ping ID redirects. Normally this would be handled in the
    browser by JavaScript, but here the form must be explicitly posted in
    order to continue the authentication flow
    """
    def _handle_response(self, document, auth_context):
        if document.has('input[name="ppm_request"]'):
            LOGGER.debug('Form redirect page detected')
            return document.extract_form().build_request()
        return None


class WebAuthnSupportHandler(AuthHandler):
    """
    Handler for Ping ID check for WebAuthn support. Since this is outside
    the context of a browser, the handler returns false for WebAuthn support
    """
    def _handle_response(self, document, auth_context):
        if document.has('form#start-form'):
            LOGGER.debug('WebAuthn support page detected')
            return document.extract_form() \
                .set('isWebAuthnSupportedByBrowser', 'false') \
                .build_request()
        return None


class SwitchDeviceHandler(AuthHandler):
    """
    Handler that initiates the switch device branch of the authentication
    flow. switch_device must be true in the auth_context in order for this
    class to handle responses
    """
    def _handle_response(self, document, auth_context):
        if auth_context.switch_device and document.has(
                'a[href="/pingid/ppm/devices"]'):
            LOGGER.debug('switch_device requested')
            LOGGER.info("Switching device...")
            auth_context.switch_device = False
            return Request('GET', urljoin(document.url, '/pingid/ppm/devices'))
        return None


class SelectDeviceHandler(AuthHandler):
    """
    Handler that allows the user to select which device to perform MFA with.
    """
    @staticmethod
    def _extract_devices_from_response(document):
        parse_device_name_from_element = lambda e: ' -- '.join(
            map(lambda line: line.strip(), e.text.strip().split('\n')))

        return {
            index: {
                'data-id': element.get('data-id'),
                'name': parse_device_name_from_element(element)
            }
            for index, element in enumerate(document.select('li.device'))
        }

    def _handle_response(self, document, auth_context):
        if document.has('form#device-form'):
            LOGGER.debug('Device selection page detected')
            devices = self._extract_devices_from_response(document)
            for key, value in devices.items():
                print("{}: {}".format(key, value['name']))
            selected_device = int(input("Select a device: "))

            return document.extract_form('device-form') \
                .set('deviceId', devices[selected_device].get('data-id')) \
                .build_request()
        return None


class MobileMFAHandler(AuthHandler):
    """
    Handler for performing MFA with the user's mobile device. This handler
    will wait until the user has performed Swipe authentication with the
    PingID app on their mobile device
    """
    @staticmethod
    def _extract_mobile_device_name(document):
        return document.select_one('div.device-name').text.strip()

    def _handle_response(self, document, auth_context):
        if document.has('form#form1') and document.has('form#reponseView'):
            LOGGER.debug('Mobile MFA page detected')
            LOGGER.info(
                "Authenticating on %s",
                self._extract_mobile_device_name(document))

            form = document.extract_form('form1')
            form.method = 'GET'
            request = form.build_request()

            get_mfa_status = lambda: auth_context.client.send_request(
                request).json().get('status')
            is_mfa_resolved = lambda: get_mfa_status() in [
                'OK', 'DEVICE_CLAIM_TIMEOUT', 'TIMEOUT']

            for retry in retry_loop(attempts=10, timeout=60, delay=3):
                if is_mfa_resolved():
                    break
                retry()

            return document.extract_form('reponseView').build_request()
        return None


class OTPMFAHandler(AuthHandler):
    """
    Handler for performing MFA with a OTP (YubiKey, SMS, or Phone). This
    handler will prompt the user for their OTP in order to perform MFA
    """
    @staticmethod
    def _extract_otp_device_name(document):
        return document.select_one('div.success-message').text.strip()

    def _handle_response(self, document, auth_context):
        if document.has('form#otp-form'):
            LOGGER.debug('OTP MFA page detected')
            LOGGER.info(self._extract_otp_device_name(document))
            return document.extract_form('otp-form') \
                .set('otp', input('Enter Passcode: ')) \
                .build_request()
        return None


class MetaRefreshHandler(AuthHandler):
    """
    Handler for dealing with meta refresh pages in the authentication flow.
    "Refreshes" the page by resubmitting the request to the same URL within
    the same session
    """
    def _handle_response(self, document, auth_context):
        if document.has('meta[http-equiv="refresh"]'):
            LOGGER.debug('Meta refresh page detected')
            return Request('GET', document.url)
        return None


class AuthSubmitHandler(AuthHandler):
    """
    Handler for dealing with an authentication submit form. Typically this
    page is handled by JavaScript in a browser.
    """
    def _handle_response(self, document, auth_context):
        if document.has('form#form1') and not document.has('form#reponseView'):
            LOGGER.debug('Auth submit page detected')
            return document.extract_form().build_request()
        return None


class PingIDResumeHandler(AuthHandler):
    """
    Handler for PingID resume authentication page in the authentication flow.
    Typically this page is handled by JavaScript in a browser but is
    explicitly submitted here to continue the authentication flow.
    """
    def _handle_response(self, document, auth_context):
        if document.has('input[name="resumePath"]'):
            LOGGER.debug('PingID resume page detected')
            return document.extract_form().build_request()
        return None


class ErrorLoggingHandler(AuthHandler):
    """
    Logs any errors returned by PingID during authentication but does not
    produce a new request, allowing downstream handlers to still handle the
    request if possible
    """
    @staticmethod
    def _extract_errors_from_response(document):
        return map(lambda e: e.text, document.find_all('div', {
            'class': 'ping-error',
            'style': lambda s: s is None
        }))

    def _handle_response(self, document, auth_context):
        for message in self._extract_errors_from_response(document):
            LOGGER.error(message)


class PingFederateLoginHandler(AuthHandler):
    """
    Handler for the PingID page that collects username and password.
    Will prompt the user for these values if they are not already present
    in the auth_context.
    """
    @staticmethod
    def _get_username_and_password(auth_context):
        if not auth_context.username:
            auth_context.username = input('Username: ')

        prompt = "Password for {}: ".format(auth_context.username)
        if not auth_context.password:
            auth_context.password = getpass.getpass(prompt)

        return (auth_context.username, auth_context.password)

    @staticmethod
    def _response_contains_errors(document):
        return bool(document.find_all('div', {'class': 'ping-error', 'style': lambda s: s is None}))

    def _handle_response(self, document, auth_context):
        if document.has('input[name="pf.pass"]'):
            LOGGER.debug('Login detected')

            # Clear password from context if errors were returned
            if self._response_contains_errors(document):
                auth_context.password = None

            username, password = self._get_username_and_password(auth_context)
            return document.extract_form() \
                .set('pf.username', username) \
                .set('pf.pass', password) \
                .build_request()
        return None


class LandingZoneAccountSelectionHandler(AuthHandler):
    """
    Handler for dealing with the account/role selection page for the Lilly
    AWS login. This page is necessary for landing zone accounts since the
    SAML response is too long for AWS. This page will take the account/role
    desired by the user and create a shorter SAML response that is acceptable
    to AWS
    """
    def _handle_response(self, document, auth_context):
        if document.has('form#loginform'):
            LOGGER.debug('Lilly LZ Account Selection page detected')
            systemid = auth_context.username.upper()

            if not auth_context.role_arn:
                # get user choice interactively
                interactive_selection = LillyAwsLogin(
                    document,
                    filter_role=auth_context.filter_role,
                    filter_account=auth_context.filter_account
                )
                selected_role = \
                    interactive_selection.get_account_and_role_selection()

                account_id = selected_role.get("account_id")
                auth_context.account_description = selected_role.get(
                    "account_description")
                auth_context.account_name = selected_role.get("account_name")
                auth_context.role = selected_role.get("role_selection_value")
                account_selection = selected_role.get(
                    "account_selection_value")
                # must set role_arn for later use when calling STS. also used
                # in base auth_context to construct account and role from this.
                auth_context.role_arn = f"arn:aws:iam::{account_id}:role/" \
                                        f"{auth_context.role}"
            else:
                # user choice was defined at invocation
                account_id = auth_context.role_arn.split(":")[4]

                # save these parameters to return with final SAML response
                account_option = [
                    option for option in document.find_all('option') if
                    account_id in str(option)][0]
                account_selection = account_option.get("value")
                auth_context.account_description = account_option.text
                auth_context.account_name = account_option.text.split(" ")[0]
                auth_context.role = auth_context.role_arn.split("/")[-1]

            # we are provided IDP if user is CA or Non-CA. We need to select
            # the right index if CA account
            idp = 1 if (systemid.endswith("-CA")) else 2
            auth_context.principal_arn = \
                "arn:aws:iam::{}:saml-provider/{}".format(
                    account_id, account_selection.split(",")[idp])

            return document.extract_form() \
                .set('systemid', systemid) \
                .set('account', account_selection) \
                .set('role', auth_context.role) \
                .build_request()
        return None


class UnknownResponseHandler(AuthHandler):
    """
    Handler that is meant to be the last link in the chain of responses.
    Will produce an error any time it is reached with an
    UnexpectedResponseError
    """
    def _handle_response(self, document, auth_context):
        LOGGER.debug(
            "We encountered an unexpected response and are unable to handle "
            "it:\nURL: %s\npage contents:\n%s\n%s",
            document.url, document.html)
        raise UnexpectedResponseError(
            "We encountered an unexpected response and are unable to handle "
            "it. URL: {}\nRetry with -v/--verbose to get more context".format(
                document.url)
        )


class UnexpectedResponseError(Exception):
    """
    An exception to show we don't recognize a response and do not know
    how to handle it.
    """
    pass


class DefaultAuthHandler(AuthHandler):
    """
    Handler that represents the chain of responsibility for the various
    handlers meant to handle responses as part of the authentication flow
    """
    def __init__(self):
        self._handler = ErrorLoggingHandler()
        self._handler.next(AWSSAMLResponseHandler()) \
            .next(LillySAMLResponseHandler()) \
            .next(FormRedirectHandler()) \
            .next(WebAuthnSupportHandler()) \
            .next(SwitchDeviceHandler()) \
            .next(SelectDeviceHandler()) \
            .next(MobileMFAHandler()) \
            .next(OTPMFAHandler()) \
            .next(AuthSubmitHandler()) \
            .next(PingIDResumeHandler()) \
            .next(PingFederateLoginHandler()) \
            .next(LandingZoneAccountSelectionHandler()) \
            .next(MetaRefreshHandler()) \
            .next(UnknownResponseHandler())

    def _handle_response(self, document, auth_context):
        return self._handler.handle_response(document, auth_context)
