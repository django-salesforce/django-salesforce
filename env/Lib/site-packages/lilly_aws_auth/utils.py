#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""
Utility, helper functions used throughout the package.
"""

from __future__ import with_statement, absolute_import, print_function
import logging
import os
import platform
import socket
import sys
import time
from textwrap import dedent


def setup_logger(arguments):
    """
    Setup a logger with variable loglevel for this applications logging,
    separate from the main logger that is inheriting the dependencies'
    loggers.
    """
    logger = logging.getLogger('main_log')
    logger.setLevel(logging.DEBUG)
    formatter = logging.Formatter(
        'lilly_aws_auth:%(levelname)s: %(message)s')
    stream_handler = logging.StreamHandler()
    stream_handler.setLevel(arguments.loglevel)
    stream_handler.setFormatter(formatter)
    logger.addHandler(stream_handler)
    return logger


def check_proxy():
    """Check if the https_proxy is set and raise appropriate warnings."""
    logger = logging.getLogger('main_log')
    if not os.environ.get('https_proxy'):
        # if no proxy is set, let's double check if we are on the Lilly
        # network to warn that a proxy should be set.
        status = check_connection_to_proxy(
            proxy='https://40.0.40.10:9000')
        if status:
            warning_message = "You do not have a proxy set, but you " \
                              "appear to be on the Lilly network. " \
                              "Consider setting the https proxy in the " \
                              "environment variable `https_proxy`, " \
                              "or you may experience issues."
            logger.warning(warning_message)
    else:
        status = check_connection_to_proxy(os.environ.get('https_proxy'))
        if not status:
            # if proxy is set but we cannot connect, log a warning that it
            # might be incorrect or should be unset.
            warning_message = "Detected a proxy, {}, set in your " \
                              "environment variable `https_proxy`, " \
                              "but failed to connect to it. Consider " \
                              "correcting your proxy setting or unset if " \
                              "you are not behind a proxy, such as not on " \
                              "the Lilly network. Failure to fix this " \
                              "may lead to issues running this tool".format(
                                  os.environ.get('https_proxy'))
            logger.warning(warning_message)


def determine_version():
    """Determine the python version being used to call this script. Helps
    handle some errors in certain versions."""
    version = "{major}.{minor}.{micro}".format(
        major=sys.version_info[0],
        minor=sys.version_info[1],
        micro=sys.version_info[2])
    return version


def check_connection_to_proxy(proxy, **kwargs):
    """
    Check connection to the proxy server and log a warning if it cannot
    establish a connection. Returns True if connection was successful,
    False otherwise.

    :param proxy: proxy hostname and port
    :keyword test: bool if this a test case to skip external calls.
    :keyword test_response: in a test case, respond with this boolean value.
    :return: bool
    """
    proxy = proxy.replace("http://", '').replace("https://", "")
    if ':' not in proxy:
        raise ValueError("Proxy is not set as expected. Need a hostname "
                         "and port, but got {}".format(proxy))
    # remove username/password
    if '@' in proxy:
        proxy = proxy.split("@")[-1]
    proxy_split = proxy.split(":")
    proxy_host = proxy_split[0]
    proxy_port = int(proxy_split[1])
    sock = socket.socket(socket.AF_INET)
    sock.settimeout(1)  # give up quickly.
    if kwargs.get('test'):
        return kwargs.get('test_response')
    try:
        result = sock.connect_ex((proxy_host, proxy_port))
        if result != 0:
            return False
        return True
    except socket.gaierror:
        return False
    except socket.timeout:
        return False


def multiline_command_seperator(message):
    """Replace 'separator' string formatter variable with platform specific
    multi-line command separator.
    If Windows, will do it twice, once for PowerShell once for CMD."""
    if platform.system().lower() == 'windows':
        final_message = 'Windows CMD:\r\n\r\n'
        final_message += dedent(message.replace('separator', '^'))
        final_message += "\r\n"
        final_message += "Windows PowerShell:\r\n\r\n"
        final_message += dedent(message.replace('separator', '`'))
        return final_message
    return message.replace('separator', '\\')


def retry_loop(attempts, timeout=None, delay=0):
    """
    Generator to help construct a polling iterator.

    :param attempts: maximum number of iterations
    :param timeout: maximum time
    :param delay: time to wait before next iteration
    :return:
    """
    start_time = time.time()
    success = set()
    for _ in range(attempts):
        success.add(True)
        yield success.clear

        if success:
            return

        duration = time.time() - start_time
        if timeout is not None and duration > timeout:
            break

        if delay:
            time.sleep(delay)

    raise TimeoutError(
        "Could not detect a successful multi-factor authentication"
    )
