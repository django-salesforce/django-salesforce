#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""Use federated SAML token to get available AWS accounts."""

from __future__ import print_function, absolute_import
from collections import OrderedDict, namedtuple
import logging
import base64

from requests.exceptions import InvalidURL

from .webpage import Client, Document
from .tui import interactive_account_role_selection

try:
    _input = raw_input
except NameError:
    _input = input

LOGGER = logging.getLogger('main_log')


class LillyAwsLogin:
    """
    Select account from aws-login.am.lilly.com list. This page was put in
    place because of the growing number of accounts causing very long SAML
    responses using the default AWS SAML login,
    so this page does the selection and shortens the response.

    No principal arn is needed in these requests since that is handled by
    the login page, we just need to select an account and role and support
    filtering and preselection here.
    """
    def __init__(
            self,
            document,
            **kwargs):
        """

        :param document: the requests document (HTML) body response from the
          aws-login page after successful authentication.
          This page should have a form with accounts and roles specific to
          that user that authenticated. This expects some standard formats
          so if those are changed, it will break this.
        :keyword filter_account: account name to filter response to only
          include this account.
        :keyword filter_role: role name to filter response to only include
          this role.
        """
        self.document = document
        self.filter_account = kwargs.get('filter_account')
        self.filter_role = kwargs.get('filter_role')

    def get_account_and_role_selection(self):
        """
        Extract roles and accounts from page, filter them if user defined
        filters, then present the options to the user for selection. Return
        the values needed to submit the form.
        :return:
        """
        raw_accounts, raw_roles = self.extract_accounts_and_roles()
        accounts = self.filter_accounts_by_name(raw_accounts)
        roles = self.filter_roles_by_name(raw_roles)
        indexed_account_roles = self.enumerate_and_sort_accounts_and_roles(
            accounts=accounts,
            roles=roles
        )
        # build prompts
        printable_roles = []
        previous_account = None
        for index, each in indexed_account_roles.items():
            if each.get('account_description') == previous_account:
                pass
            else:
                printable_roles.append(
                    f"Account: {each.get('account_description')}")
                previous_account = each.get('account_description')
            printable_roles.append(
                f"  [{index}] {each.get('role_description')}")
        selection = interactive_account_role_selection(printable_roles)
        selected_role = indexed_account_roles[int(selection)]
        return selected_role

    def extract_accounts_and_roles(self):
        """
        Extract the accounts and roles from the HTML and order accounts
        alphabetically and their constituent roles alphabetically.

        :return: A list of dictionary of accounts and a list of dictionary of
          roles. These are rather raw format here because we support
          filtering before presenting an indexed list.
        """
        LOGGER.debug("Extracting AWS account and role options from Lilly "
                     "aws-login site.")
        accounts = self.document.select(
            'select[name="account"] > option')
        if len(accounts) < 1:
            LOGGER.exception(
                "Form detection failed for aws-login.am.lilly.com. "
                "Expected to find one form select field for account with at "
                "least one account listed"
                " but saw %s and unable to extract the necessary "
                "information to continue. Consider using "
                "non-interactive approach or attempt additional "
                "troubleshooting.", len(accounts))
            raise AssertionError(
                f"Expected one form field for account "
                f"selection but found {len(accounts)}")
        roles = self.document.select('select[name="role"] > option')
        if len(roles) < 1:
            LOGGER.exception(
                "Form detection failed for aws-login.am.lilly.com."
                "Expected to find one form select field for role with at "
                "least one role"
                " but saw %s and unable to extract the necessary "
                " information to continue. Consider using "
                "non-interactive approach or attempt additional "
                "troubleshooting.", len(roles))
            raise AssertionError(
                f"Expected one form field for role "
                f"selection but found {len(roles)}")

        accounts_and_roles = []
        extracted_accounts = []
        extracted_roles = []
        for account in accounts:
            account_description = account.text
            # we must set our form selection to this value
            account_value = account.attrs.get("value")
            account_number = account_value.split(",")[0]
            account_name = None
            if "(" in account_description:
                account_name = account_description.split("(")[0].strip()
            extracted_accounts.append({
                "account_selection_value": account_value,
                "account_description": account_description,
                "account_id": account_number,
                "account_name": account_name})
        for role in roles:
            role_description = role.text
            # typically will match description, but being explicit to make
            # sure we are fetching the form values.
            role_value = role.attrs.get("value")
            for each in accounts_and_roles:
                each.append([role_description, role_value])
            extracted_roles.append({
                "role_selection_value": role_value,
                "role_description": role_description
            })
        return extracted_accounts, extracted_roles

    def filter_accounts_by_name(self, accounts):
        """
        If an account name was provided, filter to only return it as an
        option. If the filter fails to return anything or there is not a
        filter, log the failure and return the original list.
        :param accounts:
        :return:
        """
        filtered = False
        filtered_accounts = []
        if self.filter_account:
            for account in accounts:
                if account.get("account_name") == self.filter_account:
                    filtered_accounts.append(account)
                    filtered = True
            if filtered:
                return filtered_accounts
            else:
                LOGGER.debug("Failed to filter available accounts by name "
                             "provided. Returning all available accounts.")
        return accounts

    def filter_roles_by_name(self, roles):
        """
        If an account name was provided, filter to only return it as an
        option. If the filter fails to return anything or there is not a
        filter, log the failure and return the original list.
        :param roles:
        :return:
        """
        filtered = False
        filtered_roles = []
        if self.filter_role:
            for role in roles:
                if role.get("role_description") == self.filter_role:
                    filtered_roles.append(role)
                    filtered = True
            if filtered:
                return filtered_roles
            else:
                LOGGER.debug("Failed to filter available roles by name "
                             "provided. Returning all available roles.")
        return roles

    @staticmethod
    def enumerate_and_sort_accounts_and_roles(accounts, roles):
        """
        Lilly's aws login separates accounts and roles, even if they are
        not valid combinations. Naively enumerate all the combinations here
        plus sort them by account name and role name and add index for each.

        Return is more compact that input, we only need to store selection
        value and description to display.
        """
        indexed_account_roles = OrderedDict()
        index = 0
        for account in sorted(
                accounts, key=lambda _: _['account_description']):
            for role in sorted(roles, key=lambda _: _['role_description']):
                indexed_account_roles[index] = {
                    "account_description": account.get("account_description"),
                    "account_name": account.get("account_name"),
                    "account_id": account.get("account_id"),
                    "account_selection_value": account.get(
                        "account_selection_value"),
                    "role_description": role.get("role_description"),
                    "role_selection_value": role.get("role_selection_value")
                }
                index += 1
        return indexed_account_roles


class AwsSamlLogin:
    """Login to AWS through a federated entry point."""

    def __init__(self, saml_response,
                 aws_saml_signin_url='https://signin.aws.amazon.com/saml',
                 **kwargs):
        """
        :param saml_response: Security Assertion Markup Language response
          provided from the provider, Lilly, for federated authentication
         into AWS.
        :param aws_saml_signin_url: the URL to login to AWS with saml.
        :type identity_provider_url: str or unicode
        :return: function call to follow()
        :param kwargs: keyword arguments
        :keyword filter_account: account name to filter
        :keyword filter_role: role name to filter
        :keyword preselected_role_arn: A preselected role arn to be
          validated and return the associated Role if exists, otherwise
          prompt for selection will be made.
        :keyword display_limit: Set a limit for number of account-role
          options that can be displayed on-screen. If response is longer than
          this list, it will buffer into scrollable TUI.
        :type display_limit: int
        """
        self.saml_response = saml_response
        self.aws_saml_sign_in_url = aws_saml_signin_url
        self.filter_account = kwargs.get('filter_account')
        self.filter_role = kwargs.get('filter_role')
        self.preselected_role_arn = kwargs.get('preselected_role_arn')
        self.preselection_successful = False

    def get_role_info(self):
        """Sign In to AWS with SAML and get user input to filter down and
        return the arn for a selected account:role and its principal arn. """
        client = Client()
        response = client.request(
            url=self.aws_saml_sign_in_url,
            method='POST',
            data={'SAMLResponse': self.saml_response}
        )
        document = Document(response.text, response.url)
        if not is_valid_sign_in_response(document):
            raise InvalidURL(
                "Did not receive a valid AWS SAML Sign In response page, "
                "possible bad URL: {}".format(self.aws_saml_sign_in_url)
            )
        accounts_and_roles = extract_accounts_and_roles(
            document)
        selected_role = self.get_selection(accounts_and_roles)
        return selected_role

    def get_selection(self, accounts_and_roles):
        """
        Check preselected arns and validate, if they fail validation or
        are not provided, then interactively prompt for a selection.

        :param accounts_and_roles: a dict of all accounts and their roles.
        :return: namedtuple('Role', 'account role role_arn principal_id')
        """
        principal_arn_lookup = self.get_principal_arns()
        if self.preselected_role_arn:
            # just get all accounts and roles now
            roles = sort_and_index_accounts_and_roles(
                accounts_and_roles, principal_arn_lookup
                )
            selected_role = self.validate_selection(
                roles, self.preselected_role_arn)
            if selected_role:
                # to indicate downstream if it should offer to save the
                # configuration.
                self.preselection_successful = True
                return selected_role
            else:
                LOGGER.error("Could not find the selected role_arn and "
                             "principal_arn in the ones available, "
                             "will prompt for a new selection")
        # continues to prompt if no selected arns provided or the
        # selection didn't pass validation

        if self.filter_account:
            accounts_and_roles = filter_by_account_name(
                accounts_and_roles=accounts_and_roles,
                account=self.filter_account)
        if self.filter_role:
            accounts_and_roles = filter_by_role(
                accounts_and_roles=accounts_and_roles,
                role=self.filter_role
            )
        roles = sort_and_index_accounts_and_roles(
            accounts_and_roles,
            principal_arn_lookup
        )
        printable_roles = []
        previous_account = None
        for index, each in roles.items():
            if each.account_description == previous_account:
                pass
            else:
                printable_roles.append(each.account_description)
                previous_account = each.account_description
            printable_roles.append('  [{}] {}'.format(index, each.role))
        selection = interactive_account_role_selection(printable_roles)
        selected_role = roles[int(selection)]
        return selected_role

    def validate_selection(self, role_lookup, preselected_role_arn):
        """
        Check if selected_arns exist in role_lookup and return the role,
        else return None.

        :param role_lookup: a dict of namedtuples in the format:
          {index:
            Role(account_description, account, role, role_arn, principal_arn).
            }
        :param preselected_role_arn: the role arn of the desired account/role
        :return: namedtuple Role(account_description, account, role,
        role_arn, principal_arn) or None
        """
        selected_role = None
        for _, role in role_lookup.items():
            if role.role_arn == preselected_role_arn:
                # set class attribute so it can be checked downstream to
                # know when to prompt to offer to save configuration
                self.preselection_successful = True
                selected_role = role
                break
        return selected_role

    def get_principal_arns(self):
        """
        Get the principal arns that relate to the role arns.

        :return: dict of {role_arn: principal_arn}
        """
        decoded_response = base64.b64decode(self.saml_response)
        document = Document(decoded_response, None)
        roles = {}
        for role in document.find(
                'saml:attribute',
                {'name': 'https://aws.amazon.com/SAML/Attributes/Role'}
        ).find_all('saml:attributevalue'):
            role_arn, principal_arn = tuple(role.text.split(','))
            roles[role_arn] = principal_arn
        return roles


def is_valid_sign_in_response(document):
    """
    Check if the page is a valid AWS SAML sign in response page.

    :param document: Document object
    :return: bool
    """
    if document.has('form#saml_form') and document.has('div.saml-account'):
        return True
    return False


def extract_accounts_and_roles(document):
    """
    Extract the accounts and roles from the HTML and order accounts
    alphabetically and their constituent roles alphabetically.

    :param document: Document object
    :return: A dictionary of accounts with the key being its name and
      the value being a list of namedtuples of each role. Those
      namedtuples are of the form RoleMeta(name, arn)
    """
    accounts_and_roles = dict()
    for account in document.select('fieldset > div.saml-account'):
        name = account.find('div', {'class': 'saml-account-name'}).text
        role_metas = []
        roles = account.find_all('label')
        for role in roles:
            RoleMeta = namedtuple('role', 'name arn')
            role_metas.append(RoleMeta(role.text, role.get('for')))
        # sort the roles by name.
        role_metas = sorted(role_metas, key=lambda _: _[0])
        accounts_and_roles[name] = role_metas
    return accounts_and_roles


def sort_and_index_accounts_and_roles(accounts_and_roles,
                                      principal_arn_lookup):
    """
    Take a dict of accounts and their roles and sort it. Then index all
    the roles. Then return both.

    :param accounts_and_roles: a dict of accounts and their roles that has
      been extracted from the webpage.
    :param principal_arn_lookup: a dict of role arn and its principal arn
      extracted from the saml response
    :return:
        A dictionary of indices with their values being
       the Role namedtuple that contains
       Role(account_description, account, role, role_arn, principal_arn).
    """
    # make sure each account has sorted roles
    sorted_accounts_and_roles = dict()
    for key, value in accounts_and_roles.items():
        sorted_accounts_and_roles[key] = sorted(value)
    # sort the accounts by name
    sorted_accounts_and_roles = OrderedDict(sorted(
        sorted_accounts_and_roles.items(), key=lambda _: _[0]))
    # now that it is ordered, assign an index to each arn.
    account_and_role_count = 0

    Role = namedtuple(
        'Role',
        'account_description account role role_arn principal_arn'
    )
    indexed_roles = dict()

    for account, roles in sorted_accounts_and_roles.items():
        for role in roles:
            indexed_role = Role(
                account_description=account,
                account=parse_account_name(account),
                role=role.name,
                role_arn=role.arn,
                principal_arn=principal_arn_lookup[role.arn]
            )
            indexed_roles[account_and_role_count] = indexed_role
            account_and_role_count += 1
    return indexed_roles


def parse_account_name(account):
    """
    Parse an account name as given be AWS and return the name if
    exists, else the account number. This is to help parse out the given
    format 'Account: name (number)' which sometimes without a name will
    be 'Account: number'

    :param account: AWS account description of the format "Account:
      <account>" where account may be 'name (number)' or 'number'
    :return: account name if exists else number
    """
    a = account.replace("Account: ", '')
    if "(" and ")" in a:
        account_name = a.split("(")[0].strip(" ")
        return account_name
    account_number = a.strip(" ")
    return account_number


def filter_by_account_name(accounts_and_roles, account):
    """
    Take a dict and filter out results by account. If the account is
    not in the list, raise a warning and return all accounts.

    :param accounts_and_roles: dict of accounts and their roles as value
    :param account: the account name to filter by
    :return: accounts_and_roles
    """
    LOGGER.info("Filtering for account %s", account)
    # first check if account is one of the keys
    available_accounts = accounts_and_roles.keys()
    # have to filter these to get name. setup dict to be able to look
    # back to original key.
    account_map = {}
    available_account_names = []
    for each in available_accounts:
        account_name = parse_account_name(each)
        account_map[account_name] = each
        available_account_names.append(account_name)
    if account not in available_account_names:
        LOGGER.warning('Could not filter by account name: %s', account)
        return accounts_and_roles
    filtered_accounts_and_roles = {
        account_map[account]: accounts_and_roles[account_map[account]]
    }
    return filtered_accounts_and_roles


def filter_by_role(accounts_and_roles, role):
    """
    Take a dict of accounts and their roles and filter by roles. If the
    role name is not in the list of roles, raise a warning and return
    all accounts and roles as provided.

    :param accounts_and_roles: a dict of accounts and their roles.
    :param role: the role name to filter
    :return: accounts_and_roles
    """
    LOGGER.info("Filtering for role %s", role)
    filtered = False
    filtered_accounts_and_roles = dict()
    for account, roles in accounts_and_roles.items():
        role_list = []
        for each in roles:
            if each.name == role:
                filtered = True
                role_list.append(each)
        filtered_accounts_and_roles[account] = role_list
    if filtered:
        return filtered_accounts_and_roles
    LOGGER.warning('Could not filter by role name: %s', role)
    return accounts_and_roles
