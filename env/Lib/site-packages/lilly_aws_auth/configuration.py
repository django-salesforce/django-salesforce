#! /usr/bin/env python
# -*- coding: utf-8 -*-

"""
Handle configuration files. This includes ~/.aws/credentials, ~/.aws/config
and ~/.aws/lilly_config
"""

from __future__ import print_function
import os
from os.path import expanduser
import logging

# python 2 and 3 cross compatibility
try:
    import configparser
except ImportError:
    import ConfigParser as configparser
try:
    _input = raw_input
except NameError:
    _input = input

LOGGER = logging.getLogger('main_log')


def apply_credentials_and_config(settings, profile_name,
                                 credentials_path='~/.aws/credentials',
                                 config_path='~/.aws/config'):
    """
    Apply the new the credentials and config changes to their appropriate
    files.

    :param settings: a dictionary of all the fields to apply. Accepts:
      - aws_access_key_id
      - aws_secret_access_key
      - aws_session_token
      - note
      - output
      - region
    :type settings: dict
    :param profile_name: the name of the section to store the data inside the
      files.
    :type profile_name: str or unicode
    :param credentials_path: the path to the aws credentials file
    :type credentials_path: str or unicode
    :param config_path: the path to the aws config file
    :type config_path: str or unicode
    """
    # setup aws config profile name based on base profile name
    config_profile_name = 'profile {}'.format(profile_name)
    # set config file
    config_path = expand_path(config_path)
    credentials_path = expand_path(credentials_path)
    # aws uses two configuration files.. general config and credentials.
    config_config = configparser.ConfigParser()
    credentials_config = configparser.ConfigParser()
    # if the parent directory doesn't exist, make it.
    if not os.path.exists(
            os.path.abspath(os.path.join(config_path, os.pardir))):
        os.makedirs(os.path.abspath(os.path.join(config_path, os.pardir)))
    if os.path.exists(config_path):
        # try updating the config instead of writing over with a new one.
        config_config.read(config_path)
    if os.path.exists(credentials_path):
        credentials_config.read(credentials_path)
    if not config_config.has_section(config_profile_name):
        config_config.add_section(config_profile_name)
    if not credentials_config.has_section(profile_name):
        credentials_config.add_section(profile_name)

    config_config.set(config_profile_name, 'output', settings.get(
        'output', 'text'))
    config_config.set(config_profile_name, 'region', settings.get(
        'region', 'us-east-2'))

    credentials_config.set(profile_name, 'aws_access_key_id', settings.get(
        'aws_access_key_id'))
    credentials_config.set(profile_name, 'aws_secret_access_key',
                           settings.get('aws_secret_access_key'))
    credentials_config.set(profile_name, 'aws_session_token', settings.get(
        'aws_session_token'))
    credentials_config.set(profile_name, 'note', settings.get(
        'note'))
    try:
        with open(config_path, 'w+') as config_file:
            config_config.write(config_file)
        with open(credentials_path, 'w+') as credentials_file:
            credentials_config.write(credentials_file)
    except TypeError:  # py2 support
        with open(config_path, 'wb+') as config_file:
            config_config.write(config_file)
        with open(credentials_path, 'wb+') as credentials_file:
            credentials_config.write(credentials_file)
    # change permissions to 600
    os.chmod(config_path, 0o600)
    os.chmod(credentials_path, 0o600)


class LoginProfile:
    """Store and Retrieve Login Configurations"""
    def __init__(self, config_path='~/.aws/lilly_config', **kwargs):
        """
        :param config_path: path to the Lilly config with stored login
          profiles.
        :keyword login_profile: section name in the lilly config
        :keyword aws_profile: section name in the aws credentials file
        :keyword username: federated username
        :keyword entry_url: federated login entry point URL
        :keyword role_arn: AWS ARN for the role
        :keyword region: AWS region (e.g. us-east-2)
        :keyword output: Output format (json or text)
        :keyword duration: Token duration in seconds
        :keyword note: extra information to save, free form text.
        :keyword account: AWS account name. optional for save(), helps build a
          note for reference.
        :keyword account_id: AWS account ID. optional for save() if
          role_arn is supplied, otherwise this can be provided along with
          role and the tool will construct the role_arn, making that input
          not required anymore.
        :keyword role: AWS role name. optional for save(), helps build a
          note for reference.
        """
        self.config_path = expand_path(config_path)
        self.login_profile = kwargs.get('login_profile')
        self.aws_profile = kwargs.get('aws_profile')
        self.username = kwargs.get('username')
        self.entry_url = kwargs.get('entry_url')
        self.role_arn = kwargs.get('role_arn')
        self.region = kwargs.get('region')
        self.output = kwargs.get('output')
        self.duration = kwargs.get('duration')
        self.note = kwargs.get('note')
        self.account = kwargs.get('account')
        self.account_id = kwargs.get('account_id')
        self.role = kwargs.get('role')
        # to do a save in one command, we need at least these fields passed
        # in: the rest will use defaults.
        self._required_fields = ['login_profile', 'username', 'entry_url',
                                 'role_arn', 'region', 'duration', 'output']
        self.load_success = False

    def load(self, login_profile):
        """
        Retrieve a profile from the stored login configurations. Set the
        object's attributes from the stored profile.

        :param login_profile: the profile name which is the section header
          in the Lilly config.
        """
        config = configparser.ConfigParser()
        config.read(self.config_path)
        # validate profile name
        if not config.has_section(login_profile):
            LOGGER.error(
                "The selected login_profile, %s, does not exist, please "
                "continue on to make a selection.", login_profile
            )
            self.load_success = False
            return
        # validate required fields exist
        # remove 'login_profile' from check since it's the title, but we just
        # want that for saving.
        required_fields = [_ for _ in self._required_fields if not
                           'login_profile']
        missing_required_fields = [_ for _ in required_fields if not
                                   config.has_option(login_profile, _)]
        if missing_required_fields:
            raise MissingRequiredFieldError(
                "Missing required fields in {path} for {login_profile}: "
                "{fields}".format(
                    path=self.config_path,
                    login_profile=login_profile,
                    fields=', '.join(missing_required_fields)
                ))

        self.login_profile = login_profile
        # if no aws_profile, default to use same name as login_profile
        self.aws_profile = config.get(login_profile, 'aws_profile') or login_profile
        self.note = config.get(login_profile, 'note')
        self.username = config.get(login_profile, 'username')
        self.entry_url = config.get(login_profile, 'entry_url')
        self.role_arn = config.get(login_profile, 'role_arn')
        self.region = config.get(login_profile, 'region')
        self.output = config.get(login_profile, 'output')
        self.duration = int(config.get(login_profile, 'duration'))
        self.load_success = True

    def save(self):
        """
        Store a login profile configuration. If not all required fields are
        set, interactive wizard will launch to get details for the rest of
        the profile.
        :return: invocation message
        """
        # if the parent directory doesn't exist, make it.
        if not os.path.exists(os.path.abspath(
                os.path.join(self.config_path, os.pardir))):
            os.makedirs(
                os.path.abspath(
                    os.path.join(self.config_path, os.pardir)))
        config = configparser.ConfigParser()
        if os.path.exists(self.config_path):
            # try updating the config instead of writing over with a new one.
            config.read(self.config_path)

        # conditionally check if role AND account_id were supplied and NOT
        # role arn, and if so create the role_arn here.
        if not getattr(self, 'role_arn', None):
            # if role_arn isn't defined, see if role and account_id are
            if getattr(self, 'role', None) and getattr(self, 'account_id',
                                                       None):
                self.role_arn = "arn:aws:iam::{account_id}:role/{role}".format(
                    account_id=self.account_id,
                    role=self.role
                )

        # see if attributes are set for required fields so we can
        # immediately create the profile.
        missing_required_fields = [_ for _ in self._required_fields if not
                                   hasattr(self, _) or getattr(self, _) is
                                   None]
        # interactively get the values if we don't have all the required
        # fields.
        if missing_required_fields:
            self.wizard()
        else:
            # set empty defaults if not passed in
            if not self.account:
                self.account = ''
            if not self.role:
                self.role = ''
            if not self.account_id:
                self.account_id = ''
            if not self.aws_profile:
                # default is to just use the same name
                self.aws_profile = self.login_profile

        # apply changes
        if not config.has_section(self.login_profile):
            config.add_section(self.login_profile)
        config.set(self.login_profile, 'aws_profile', self.aws_profile)
        config.set(self.login_profile, 'username', self.username)
        config.set(self.login_profile, 'account', self.account)
        config.set(self.login_profile, 'account_id', self.account_id)
        config.set(self.login_profile, 'role', self.role)
        config.set(self.login_profile, 'entry_url', self.entry_url)
        config.set(self.login_profile, 'role_arn', self.role_arn)
        config.set(self.login_profile, 'region', self.region)
        config.set(self.login_profile, 'output', self.output)
        config.set(self.login_profile, 'duration', str(self.duration))

        if self.account and self.role:
            descriptor = '{}:{}'.format(self.account, self.role)
        elif self.account:
            descriptor = self.account
        elif self.role:
            descriptor = self.role
        else:
            descriptor = self.role_arn
        note = "Saved login_profile to get credentials for {}. To use this " \
               "saved login_profile, use `lilly-aws-auth login " \
               "{}`".format(descriptor, self.login_profile)
        config.set(self.login_profile, 'note', note)
        try:
            with open(self.config_path, 'w+') as config_file:
                config.write(config_file)
        except TypeError:  # py2 support
            with open(self.config_path, 'wb+') as config_file:
                config.write(config_file)
        # change permissions to 700
        os.chmod(self.config_path, 0o700)
        message = note + ". This profile is stored in {}".format(
            self.config_path)
        return message

    def wizard(self):
        """
        Interactive login_profile configuration setup.
        Sets object attributes based on user response.
        """
        print("Create a new Stored Profile by responding to the prompts.\n")
        if not self.login_profile:
            self.login_profile = get_interactive_input(
                'Login Profile Name', required=True
            )
        if not self.aws_profile:
            self.aws_profile = get_interactive_input(
                'AWS Profile Name', default=self.login_profile
            )
        if not self.entry_url:
            self.entry_url = get_interactive_input('Entry URL', required=True)
        if not self.username:
            self.username = get_interactive_input('Username', required=True)
        if not self.account:
            self.account = get_interactive_input('Account', required=False)
        if not self.account_id:
            self.account_id = get_interactive_input(
                'Account ID', required=False)
        if not self.role:
            self.role = get_interactive_input('Role', required=False)
        # role arn can be created if account id and role were defined
        default_role_arn = None
        if getattr(self, 'role', None) and getattr(self, 'account_id', None):
            default_role_arn = "arn:aws:iam::{account_id}:role/{role}".format(
                account_id=self.account_id,
                role=self.role
                )
        if not self.role_arn:
            self.role_arn = get_interactive_input('Role ARN', required=True,
                                                  default=default_role_arn)
        if not self.region:
            self.region = get_interactive_input(
                "Region", default='us-east-2', required=True
            )
        if not self.output:
            self.output = get_interactive_input(
                "Output Format", default='json', required=True,
                validator=validate_output_format
            )
        if not self.duration:
            self.duration = get_interactive_input(
                "Duration (seconds)", default='3600', required=True,
                validator=valid_duration
            )


def expand_path(path):
    """Expand a path to an absolute path, even if it has ~ or $HOME."""
    if '~' in path or '$HOME' in path:
        return os.path.abspath(expanduser(path))
    return os.path.abspath(path)


def get_interactive_input(question, default=None, required=False, **kwargs):
    """
    Prompt for user input. Enforce that required fields cannot be null.

    :param question: text to display
    :param default: a default value to use on empty return
    :param required: Bool whether it must be nonnull
    :keyword validator: an optional validation function for the response,
      should return True or False and print a failure message.
    :return: str or unicode
    """
    def optional_validation(term, validation_func):
        """
        Check if validation is required and return response or None if so.

        :param term: term to validate
        :param validation_func: function to do validation or None
        :return: The term if validated, term if no validation required,
            else None
        """
        if validation_func:
            if validation_func(term):
                return term
            return None
        return term
    validator = None
    if kwargs.get('validator'):
        validator = kwargs.get('validator')
    prompt = "{required}: ".format(
        required=' (required)' if required else ''
    )
    if default is not None:
        prompt = "{required} [{default}]: ".format(
            required=' (required)' if required else '',
            default=default)
    while True:
        response = _input(question + prompt)
        if response != '':
            response = optional_validation(response, validator)
            if response:
                return response
        elif default is not None and response == '':
            return default
        elif default is None and response == '' and required:
            print("Response is required")
        elif default is None and response == '' and not required:
            response = optional_validation(response, validator)
            if response is not None:
                return response


class MissingRequiredFieldError(Exception):
    """Exception if profile is missing a required field."""


def validate_output_format(term):
    """Checks that the output format is one of json or text"""
    if term not in ['json', 'text']:
        print("Output format must be 'json' or 'text'")
        return None
    return term


def valid_duration(seconds, min_value=900, max_value=36000):
    """
    Validate duration entered. Must be a positive integer between specified
    values.

    :param seconds: the passed in argument
    :param min_value: set by aws minimum botocore range
    :param max_value: the maximum allowed value. Set by Lilly policy.
    :returns: valid duration in seconds
    """
    error_message = "Duration must be a positive integer equal to or " \
                    "between {} and {}".format(min_value, max_value)
    if not isinstance(seconds, int):
        try:
            seconds = int(seconds)
        except ValueError:
            print("Please enter an integer")
            return None
    if not min_value <= seconds <= max_value:
        print(error_message)
        return None
    return seconds


def list_profiles(config_path='~/.aws/lilly_config') -> str:
    """
    Lists all available profiles.

    :param config_path: path to lilly-aws-auth configuration file. Default
      is ~/.aws/lilly_config
    """

    config = configparser.ConfigParser()
    config.read(expand_path(config_path))

    output = ['Available profiles:', *config.sections()]

    return '\n'.join(output)
